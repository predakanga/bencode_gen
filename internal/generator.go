package internal

import (
	"bufio"
	"fmt"
	"github.com/dave/jennifer/jen"
	"github.com/predakanga/bencode_gen/internal/tokens"
	"github.com/predakanga/bencode_gen/pkg"
	log "github.com/sirupsen/logrus"
	"go/ast"
	"go/token"
	"go/types"
	"golang.org/x/tools/go/packages"
	"io"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
)

const DoNotEditHeader = "Code generated by %v %v DO NOT EDIT."
var autogenRegex = regexp.MustCompile(`(?m)^// Code generated .* DO NOT EDIT\.$`)
var forcePackages = []string{"github.com/predakanga/bencode_gen/pkg", "time"}

var pkgCfg = packages.Config{
	Mode: packages.NeedName |
		packages.NeedFiles |
		packages.NeedImports |
		packages.NeedTypes |
		packages.NeedTypesInfo,
	Fset:       token.NewFileSet(),
	BuildFlags: []string{"-tags", "generate"},
}


func DoGenerate(packageNames []string, typeNames []string, mode OutputMode) {
	log.Debugf("Got packageNames: %#v", packageNames)
	// Sort the type names, to make it easier to check membership
	sort.Strings(typeNames)

	// Make sure we always load ourselves and time (for interfaces)
	packageNames = append(packageNames, forcePackages...)
	// Load the packages
	pkgs, err := packages.Load(&pkgCfg, packageNames...)
	if err != nil {
		log.Fatalf("Couldn't load packages: %v", err)
	}

	// Find our requisite interfaces
	var bencodeInterface *types.Interface
	var durationType types.Type
	for _, pkg := range pkgs {
		if pkg.PkgPath == "github.com/predakanga/bencode_gen/pkg" {
			bencodeInterface = pkg.Types.Scope().Lookup("Bencodable").Type().Underlying().(*types.Interface)
		}
		if pkg.PkgPath == "time" {
			durationType = pkg.Types.Scope().Lookup("Duration").Type()
		}
	}
	if bencodeInterface == nil {
		log.Fatalf("Could not locate type: github.com/predakanga/bencode_gen/pkg.Bencodable")
	}
	if durationType == nil {
		log.Fatalf("Could not locate type: time.Duration")
	}

	// Check each package for interesting types
	for _, pkg := range pkgs {
		if strContains(forcePackages, pkg.PkgPath) {
			continue
		}
		log.Debugf("Searching package: %v (%+v)", pkg.PkgPath, pkg)
		for k, v := range pkg.TypesInfo.Defs {
			if interestingDef(k, v, typeNames) {
				pkgGen := &PackageGenerator{
					pkg:              pkg,
					bencodeInterface: bencodeInterface,
					durationType:     durationType,
				}
				pkgGen.Generate(typeNames, mode)
				break
			}
		}
	}
}

type PackageGenerator struct {
	pkg              *packages.Package
	bencodeInterface *types.Interface
	durationType     types.Type
	types map[string][]tokens.CodeToken
}

func (pg *PackageGenerator) Generate(typeNames []string, mode OutputMode) {
	// Determine our output file
	if len(pg.pkg.GoFiles) == 0 {
		log.Fatalf("Could not determine package location for %v", pg.pkg)
	}
	outDir := filepath.Dir(pg.pkg.GoFiles[0])
	outPath := filepath.Join(outDir, "bencode_gen.go") // Make sure any existing file is our own
	log.Printf("Generating bencoders for %v (%v)", pg.pkg, outPath)

	// Build up our output-tree
	generatedTypes := pg.generateForTypeNames(typeNames)
	if len(generatedTypes) == 0 {
		log.Printf("Skipping %v - no valid types found", pg.pkg)
		return
	}

	// Then output if necessary
	if mode != DryRun {
		// Check that any existing file is auto-generated
		if fileExists(outPath) && mode != Overwrite {
			f, err := os.OpenFile(outPath, os.O_RDONLY, 0644)
			if err != nil {
				log.Fatalf("Could not open %v for reading: %v", outPath, err)
			}
			defer must(f.Close)
			if !autogenRegex.MatchReader(bufio.NewReader(f)) {
				log.Fatalf("%v does not seem to be auto-generated; not overwriting it. Use --force to override this.", outPath)
			}
		}

		// Do our actual output
		// Create the temporary file in our output dir, so that we know we can just rename it later
		file, err := ioutil.TempFile(outDir, ".bencode_gen.*.go")
		if err != nil {
			log.Fatalf("Could not create output file: %v", err)
		}
		tmpPath := file.Name()
		log.Debugf("Temporary output file is: %v", tmpPath)

		pg.writePackage(file)

		// Then close the output file and run it through gofmt
		log.Debugf("Running gofmt -w %v", tmpPath)
		if err := exec.Command("gofmt", "-w", tmpPath).Run(); err != nil {
			if _, ok := err.(*exec.ExitError); !ok {
				log.Fatalf("Failed to run gofmt: %v", err)
			}
		}
		// Move it into place
		if err := os.Rename(tmpPath, outPath); err != nil {
			log.Fatalf("Failed to replace output file: %v", err)
		}
	}

	// And finally, inform the user
	log.Printf("Wrote %v with encoders for %v", outPath, strings.Join(generatedTypes, ", "))
}

func (pg *PackageGenerator) generateForTypeNames(names []string) (genTypes []string) {
	includeTaggedStructs := len(names) == 0 || strContains(names, "*")

	// Find out what types we want, and generate them
	for id, obj := range pg.pkg.TypesInfo.Defs {
		if id.Obj == nil || id.Obj.Kind != ast.Typ {
			continue
		}

		if types.Implements(obj.Type(), pg.bencodeInterface) {
			continue
		}

		if strContains(names, id.Name) || (includeTaggedStructs && structHasTag(obj.Type(), id.Name)) {
			genTypes = append(genTypes, id.Name)
			pg.generateForType(id, obj)
		}
	}

	return
}

func (pg *PackageGenerator) generateForType(id *ast.Ident, obj types.Object) {
	log.Debugf("Generating implementation for %v", id.Name)

	// Set up a panic handler to allow *Tokens functions to panic
	defer func() {
		err := recover()
		if err != nil {
			log.Fatalf("Failed to generate type %v - %v", id.Name, err)
		}
	}()

	// Get the token list for this type
	ctx := typeContext{}
	toks := pg.typeTokens("x", obj.Type(), &ctx)
	// Optimization passes
	toks = tokens.MergeConsts(toks)

	// And store it
	if ctx.NeedsSort {
		toks = append([]tokens.CodeToken{&tokens.MapSort{}}, toks...)
	}

	if pg.types == nil {
		pg.types = make(map[string][]tokens.CodeToken)
	}
	pg.types[id.Name] = toks
}

func (pg *PackageGenerator) writePackage(w io.Writer) {
	genFile := jen.NewFilePathName(pg.pkg.PkgPath, pg.pkg.Name)

	// Header
	genFile.HeaderComment(fmt.Sprintf(DoNotEditHeader, pkg.Name, pkg.Version))
	genFile.HeaderComment("//+build !generate")

	// Then (sorted) types
	typeNames := make([]string, 0, len(pg.types))
	for k := range pg.types {
		typeNames = append(typeNames, k)
	}
	sort.Strings(typeNames)

	for _, k := range typeNames {
		// Function declaration
		fn := genFile.Func().
			Parens(jen.Id("x").Op("*").Id(k)).
			Id("WriteTo").
			Params(jen.Id("w").Qual("github.com/bencode_gen/pkg", "Writer")).
			Parens(jen.Err().Error())
		// Render the actual syntax tree
		fn.BlockFunc(func(g *jen.Group) {
			for _, tok := range pg.types[k] {
				tok.GenerateAST(g)
			}
			g.Line()
			g.Return()
		})
		genFile.Line()
	}

	if err := genFile.Render(w); err != nil {
		log.Fatalf("Failed to render syntax tree: %v", err)
	}
}
